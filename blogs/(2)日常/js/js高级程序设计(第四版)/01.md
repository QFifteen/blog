# 一、前言

红宝书(《JavaScript高级程序设计》第四版)学习笔记，做一个前端所应有的学习。涉及范围： 

- 第一章：什么是JavaScript
- 第二章：HTML中的JavaScript
- **第三章：语言基础**

# 二、JavaScript认识

## 2.1 了解

1995年，`JavaScript`问世。从简单的输入验证到强大的编程语言，`JavaScript`的崛起为我们带来了机遇。了解其**本质**、**历史**、及**局限性**很重要。

关键词：网景公司、微软、Web浏览器领域、ECMAScript

> JavaScript之父：Brendan Eich

<p align="center">
    	<img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic2.zhimg.com%2F50%2Fv2-24b942cae60667fd094834eb8ba9798f_hd.jpg&refer=http%3A%2F%2Fpic2.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1659078667&t=5c3b2ea9a227d5e3562bbba777b24cd8">
</p>

## 2.2 初步

完整JavaScript包括以下几个部分：

- 核心(ECMAScript)
- 文档对象模型(DOM)
- 浏览器对象模型(BOM)

### 2.2.1 DOM 

文档对象模型 `DOM`将整个页面抽象为一组分层节点。HTML页面的每个组成部分都是一种节点，包含不同的数据。

```html
<html>
    <head>
        <title>Hello</title>
    </head>
    <body>
        <p>
            World
        </p>
    </body>
</html>

html
  - head
	- title
	  - Hello
  - body
	 - p
	  - World
```



`DOM`通过创建文档树，让开发者随心所欲控制网页内容和结构，使用DOM.API可以轻松地删除、添加、替换、修改节点。



### 2.2.2 BOM

浏览器对象模型API，用于支持访问和操作浏览器的窗口。使用BOM，开发者可以操控浏览器显示页面之外的部分。

### 2.2.3 小结语

js是一门用来与网页交互的脚本语言。js的三大组成部分在`IE`、`Firefox(火狐)`、`Safari(苹果浏览器)`、`Chrome(谷歌)`、`Opera(欧朋浏览器)`得到了不同程度支持。



# 三、Script标签

JavaScript插入到HTML中，主要方法是使用`<script>`元素，有八个属性：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="index.js"></script>
    <script>
        //从上往下

        //<script>标签可接受的属性
        // 1.async：表示应该立即开始下载脚本。只对外部脚本文件有效
        // 2.charset：代码字符集
        // 3.crossorigin：配置相关请求的CORS
        // 4.defer：在文档解析和显示完成后再执行脚本。只对外部脚本文件有效。推迟到文档渲染完毕后再执行
        // 5.integrity：可确保CDN不会提供恶意内容
        // 6.language：废弃
        // 7.src：要执行代码的外部文件
        /* 8.type：代替language，表示代码块中脚本语言的内容类型，一般text/javascript。
        当值为module时，代码会被当做ES6模块，可以出现import和export*/
    </script>

    
    <!-- <script src="www.baidu.com">
        在解析这个资源时，会向src属性指定的路径发送一个Get请求，以取得资源
    </script> -->
</body>
</html>
```



`<script>`标签通常会放在`<body>`元素的后面，是为了让页面先渲染。在js代码处理之前，先渲染页面，给用户体验更好。



# 四、语言基础

## 4.1 了解

- js语法很大程度借鉴了C语言和其他类C语言，如`Java`

- **js中一切都区分大小写**
- 标识符(变量名)，推荐使用驼峰大小写形式，首字母小写，后面每个单词的首字母大写，如`firstSecond`、`myCar`
- 注释与C语言风格一致，单行注释：`//`、多行注释：`/**/`
- 严格模式，在脚本开头加入`"use strict"`
- 语句以分号结尾。虽不是必需，但为了规范，应该加上
- 最好不要使用保留的关键字和保留字作为变量名和属性名

## 4.2 变量

js变量是松散类型(弱类型)，**变量可以用于保存任何类型的数据**。3个关键词：`var`、`let`、`const`，

`var`在所有版本可用，`let`和`const`在ES6及更晚版本可用。



### 4.2.1 var 声明

定义变量，用`var`操作符

```js
var name; //定义了一个名为name的变量，变量的值是undefined

//可以改变值的类型
var name = "十五"; //值类型是"字符串"
name = 15; //变为 数字
```



定义多个变量，用逗号分隔每个变量：

```js
var message = "十五",
    age = 18,
    found = false;
```

`var`也可以重复声明

```js
var name = "十五";
var name = "十六";
console.log(name); //十六
```



**(1) var变量提升**

js的引擎会获取所有被声明的变量，然后将其提升到头部运行，这叫做**变量提升**



代码的模样：

```js
console.log(name);
var name = "十五";
```

这里，js引擎将 `name` 这个变量提升到头部，然后输出 `log`，会显示 `undefined`。然后下一步再进行赋值。代码的实际是：

```js
var name;
console.log(name); //undefined
name = "十五";
```



或者

```js
function test(){
    console.log(name);
    var name = "十五";
}
test(); //undefined
```

实际编译后，代码是这样：

```js
function test(){
    var name;//变量提升到函数顶部
    console.log(name); //undefined
    name = "十五";
}
```



> ES6的let和const是块级作用域，不存在变量提升

### 4.2.2 let 声明

`let`和`var`作用差不多，区别在于`let`声明的范围是块级作用域。`var`声明的范围是函数作用域

**块级作用域，即只可作用于当前范围，在这之外的范围，将不存在**

```js
if(true){
    let me = 15; //只存在于当前作用域
    console.log(me);//15
}
console.log(me);//me 未定义
```

同时，`let`在**同一块作用域**中不允许重复声明，在不同或嵌套的块作用域中，相同的声明是不会报错的。

```js
let age = 15;
if(true){
    let age = 20;
    console.log(age); //20
}
```



注意，与`var`的变量提升不同的，`let`不存在变量提升，而是存在**暂时性死区**。上面这段代码改变位置：

```js
if(true){
    console.log(age); //ReferenceError: Cannot access 'age' before initialization
    let age = 20;
}
```

`age`并未被定义，在`let age = 20`声明之前，都存在暂时性死区，会抛出`ReferenceError`。



**`for`循环的`let`声明**

在使用`var`来定义的变量进行循环时，迭代定义的变量会渗透到这个循环的外部

```js
for(var i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 0); //这是宏任务，会最后运行
}
// 5、5、5、5、5
//导致退出循环的是 i = 5，i = 5 不满足继续运行的条件;
//当循环体退出时，这时i的值是5，var的变量提升会让i一直等于5。
//所以在执行到setTimeout时，会一直输出5

for(let i = 0; i < 5; i++) {
    setTimeout(() => console.log(i), 0);
}
//0、1、2、3、4
//使用let，引擎每次都给一个新的迭代变量，每个setTimeout引用的都是不同的变量实例。
```



### 4.2.3 const 声明

`const`的行为与`let`基本相同，也是块级作用域、拥有暂时性死区，并且不允许重复声明。一个区别是用`const`声明变量时，必须同时初始化变量，也就是必须给赋值，且这个值一般是常量，不允许改变

> 虽然说不允许改变，是指向的地址不允许改变，比如`const obj = { name:""十五, age: 15 }`
>
> 可以改变`obj`的属性，但这个对象本身是不可变的。

`cosnt`一般用来声明常量。

```js
const name = "十五"; //不允许改变
```



`for`循环中不能用`const`来声明迭代变量，因为它会一直变化，自增。除非是声明一个不会被修改的`const`变量



### 4.2.4 风格与小结

>怪异的`var`!!!!!!!!!!

使用`let`和`const`有助于提高代码质量。推荐风格：

- 尽量不使用`var`，限制只使用`let`、`const`
- `const`优先，`let`次之

# 五、数据类型

- `js`总有 8 种数据类型，分别是 

  1. `string`：字符串类型，如文本`hello`
  2. `number`：数字类型，`1`
  3. `boolean`：布尔类型，如`true`和`false`
  4. `undefined`：未定义的，无任何值
  5. `null`：表示空值，一般用在`object`对象上
  6. `symbol`：独一无二的值，是ES6新增的数据类型
  7. `object`：对象类型，是复杂数据类型
  8. `bigint`：大整数类型

  除去`bigint`，前六种称为简单数据类型(原始类型)，`object`是复杂类型。

  

  `object`是复杂数据类型，分为

  - 狭义对象(object)
  - 数组(array)
  - 函数(function)

>数组是特殊的对象



## 5.1 typeof 操作符

`js`有三种方法，可以确定一个值到底是什么类型

- `typeof`运算符
- `instanceof`运算符
- `Object.prototype.toString`方法



`typeof`返回一个值的数据类型

```js
typeof 15; //number
typeof "15"; //string
typeof true; //boolean

function f(){}
typeof f; //function

typeof null; //object 历史原因造成
typeof window; //object
typeof {} // "object"
typeof [] // "object"
```



## 5.2 数据类型

### 1.undefined 类型

使用`var`或`let`声明了变量且并没有赋值时，变量为`undefined`。

> 不必显式的去给变量设置`undefined`值

```js
if(!undefined){
    //....会执行
}
if(undefined){
    //....不会执行
}
```



### 2.Null 类型

代表**空值**，空对象指针。在定义保存对象值的变量时，使用`null`来初始化

```js
let obj = null; //规范，表示将要保存的是对象
```



`undefined`由`null`派生而来，所以表面上相等。

```js
null == undefined; //true
```



```js
if(null){
    //....不执行
}
if(!null){
    //....执行
}
```



### 3.Boolean 类型

布尔值有两个字面量：`true`和`false`。`true`代表真，`false`代表假。一般会用于在条件判断上。

其他类型都有其等价的交换值，要转换的话，使用`Boolean()`转型函数。

`boolean`对于各类型有转换规则：除下面六个值转为`false`，其他值都视为`true`

- `false`
- `0`
- `null`
- `undefined`
- `NaN`
- `""`和`''`

有些时候，转换规则会起到很好的作用

```js
let message = "hello";
if(message){
    //....会执行
}
```



### 4.Number 类型



`Number`类型表示整数和浮点值。基本的数值是十进制整数。`let age = 18;`

最基本的数值字面量格式为十进制整数。`js`对整数提供四种进制：十进制、十六进制、八进制、二进制

- 十进制：没有前导0的数值。
- 八进制：有前缀`0o`或`0O`的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
- 十六进制：有前缀`0x`或`0X`的数值。
- 二进制：有前缀`0b`或`0B`的数值。

**(1)浮点数**

定义浮点数，在数值中要包含小数点，且小数点后必须至少有一个数字。

> 浮点数存储空间是整数的两倍，所以js会尽量转成整数



面试题：`0.1 + 0.2 = 0.3?`，`0.1`加`0.2`得到的不是0.3，而是`0.300 000 000 000 000 04`

> 浮点值的精准度最高可达17位数，不要测试某个特定的浮点值
>
> 之所以有这错误，在于使用IEEE 754数值



**(2)值的范围**

`js`可表示的最小数值在`Number.MIN_VALUE`，一般是`5e-324`，最大数值在`Number.MAX_VALUE`，一般是`1.7976931348623157e+308`



`Infinity`代表无穷。正的数值太大或负的数值太大，无法表示。

- `Infinity`代表正无穷
- `-Infinity`代表负无穷

**(3) NaN**

特殊数值 `NaN`，代表是**非数字(Not a Number)**，

> NaN不是数据类型，它依然属于Number，用typeof即可看见

```js
5 - 'x'; //NaN
```



弱类型的`js`会将字符串`x`转换成数值，可`x`不是数值，所以结果为`NaN`

`NaN`不等于任何值

```js
NaN === NaN; //false
```



**(4) isNaN() 函数**

`isNan()`接受一个参数，可以是任意数据类型，判断是否 **不是数值**

```js
isNaN(15); //是数值，返回false
isNaN('hello'); //字符串，返回true
isNaN(''); //false
isNaN(NaN); //true

let message = 'hello';
if(isNaN(message)){
    //....执行
}
```

>`isNaN`只对数值有效，如果传入其他值，会被先转成数值

```js
isNaN('Hello'); // true
// 相当于
isNaN(Number('Hello')); // true
```



对于空数组和一个数值的数据，`isNaN`返回`false`

```js
isNaN([]); // false
isNaN([123]); // false
isNaN(['123']); // false

isNaN(''); //false
```

原因在于这些数组能被`Number()`转换成数值，这需要知道`Number`函数的转换规则



**(5) 数值转换**

将非数值转换成数值，3种。`Number()`、`parseInt()`、`parseFloat()`

`Number()`可用于任何数据类型，后两种主要 字符串转数值。

`Number()`转换规则：

- `true`转换成 1，`false` 成 0
- 数值 直接返回
- `null`，返回0
- `undefined` 返回 `NaN`
- 字符串
  - 空字符串，返回0
  - 字符串包含数值，返回数值，会忽略无谓的0
  - 包含有效浮点值格式，返回相应浮点值



在需要得整数，可以优先`parseInt()`，专注字符串是否包含数值。从非空字符开始转换。

如果第一个字符不是数值或加号、减号，返回`NaN`。空字符串会返回`NaN`。

第一个字符是数值、加号或减号，则依次检测每个字符。

```js
parseInt("15blue"); //返回仅数值部分
parseInt(""); //NaN
parseInt("15.5"); //转整数，15

```

`parseInt()`可接收第二个参数，代表进制。默认是十进制，可以使用`parseInt`来处理进制的转换

```js
parseInt("0XAF",16); 
```



`parseFloat()`将一个字符串转为浮点数，忽略字符串开头的零。只解析十进制值，不能指定底数。

```js
parseFloat(3.14); //3.14
parseFloat('3.14fifteen'); //3.14，不能转换的字符，不再进行往后转换
parseFloat("22.34.5")； //22.34，第二个小数点不予转换
```



### 5.String 类型

字符串用`''`或`""`表示，有一些转义字符(字符字面量)：

| 字面量 | 含义       |
| ------ | ---------- |
| \n     | 换行       |
| \t     | 制表       |
| \b     | 退格       |
| \r     | 回车       |
| \f     | 换页       |
| \\\\\  | 反斜杠(\\) |
| \\'    | 单引号(')  |



使用`toString()`可以将数值、布尔值、对象和字符串值返回当前值的字符串等价物。`null`和`undefined`没有`toString()`方法。

> 在对一个数值时，`toString()`可以接受一个底数参数，如`toString(8)`得到数值的八进制



`String()`转型函数，返回相应类型值的字符串格式。值是`null`，就返回`null`，`undefined`同。

**(1)模板字面量**

可以跨行定义字符串，也支持字符串插值。

```js
let name = `first line
			second line`;
```



**(2)字符串插值**

可以通过在`${}`中使用一个`js`表达式来实现：

```js
let name = '十五'
console.log(`你好啊，我是${name}`)
```

配合模板字面量反引号来使用，可以很方便，插入的值会用`toString()`来强制转换成字符串。

> 任何`js`表达式都可以用于插值。也可以在插值表达式中调用函数和方法



### 6.Symbol 类型

`Symbol`是ES6新增的数据类型。是唯一、不可变的。用于确保对象属性是唯一标识符，不发生属性冲突的危险。符号用来创建唯一标记。

```js
let sym = Symbol();
let sym2 = new Symbol(); //Symbol is not a constructor
```

> `Symbol()`不能与`new`一起作构造函数使用



**全局符号注册表**

使用全局符号`Symbol.for()`注册表，使用`Symbol.keyFor()`来查询全局注册表

```js
let sym = Symbol.for("foo"); //注册新符号添加到注册表中
console.log(Symbol.keyFor(sym)); // foo

//注意，必须是全局注册的符号，如不是，则返回undefined
let sym2 = Symbol("bar");
console.log(Symbol.keyFor(sym2)); //undefined
```

> 如果给`keyFor()`的不是符号，则会抛出错误。

:star: <4.常用内置符号> 47页 - 55页

 

### 7.Object 类型

对象就是一组数据和功能的集合，通过`new`创建。给对象添加属性和方法

```js
let obj = new Object();
```



1. `constructor`，构造器，创建当前对象的函数。
2. `hasOwnProperty(propertyName)`，判断对象实例是否存在某属性，属性名必须是字符串
3. `isPrototypeOf(object)`，判断当前对象是否为另一个的原型
4. `propertyIsEnumerable(propertyName)`，判断给定属性是否可用，属性名必须是字符串
5. `toLocaleString()`，返回对象的字符串表示
6. `toString()`，返回对象的字符串表示
7. `valueOf()`，返回对象对应的字符串、数值或布尔值表示。

>`object`是所有对象的基类，所以是对象，就有如上的属性和方法。

```js
let obj = new Object({
    name:"十五",
    age:18
});

obj.constructor = function Student(){console.log("十五")} //{name: '十五', age: 18, constructor: ƒ}

obj.hasOwnProperty("name"); //true
obj.propertyIsEnumerable("age")； //true
obj.toLocaleString(); //'[object Object]'
obj.toString(); //'[object Object]'
obj.valueOf(); //{name: '十五', age: 18, constructor: ƒ}
```



# 六、操作符

可用于操作数据值的操作符，可用于各种值，包括字符串、数值、布尔值、和对象。



## 6.1 一元操作符

只能操作一个值的操作符

### 1. 递增/递减

前缀版，位于操作的变量前头，**变量的值会在语句被求值之前改变**

```js
let age = 18;
age = ++ age;
//实际情况
age = age + 1; 

age = -- age;
//实际情况
age = age - 1;
```

```js
let num1  = 1;
let num2 = 21;

let num3 = ++ num1 + num2; //23，先执行前缀的 ++ ，再相加

let num4 = num1 + num2; //23，num1 使用的是递加后的值
```

后缀版，位于操作的变量后头，**变量的值会在语句被求值之后才发生**

```js
let num1 = 1;
let num2 = 21;

let num3 = num1-- + num2; //22，在这里是不执行减的，在下面的求值中才会

let num4 = num1 + num2; //21，这时，num1的值是0，因为执行了后缀的-- 。被求值之后
```



前缀与后缀的4个操作符，不止作用在数值上，在字符串、布尔值、浮点值或对象上，都有对应规则：

- 字符串，有效的数值形式，会先转换成数值再改变。类型变成`number`

```js
let age = "15";
age = ++ age; // 16
```

- 字符串，无效的数值形式，变量值为`NaN`。类型变成`number`

```js
let name = "十五";
name = ++ name; //NaN
console.log(typeof name); //number
```

- 布尔值，`false`，转换成 0 再改变，类型变成`number`
- 布尔值，`true`，转换成 1 再改变，类型变成`number`

```js
let is = false; //转换成 0
is = ++ is; //1

let is2 = true; //转换成 1
is2 = ++ is2; //2
```

- 浮点值，加 1 或减 1 即可。
- 对象，会调用`valueOf()`方法取得可以操作的值 :star: 53页

## 6.2 一元加、减符

`+` 和 `-`，执行与`Number()`一样的类型转换

```js
let age = "15";
age = +age; //15

let is = false;
is = + is; //0
//...
```

> 用于数据类型转换



## 6.3 位操作符

:star: 59页 - 63页

## 6.4 布尔操作符

### 1. 逻辑非(!)

逻辑非操作符用一个叹号 `!` 表示，始终返回布尔值。首先将其转换成布尔值，再取反。规则：

- 对象，本是`true`，取反返回`false`
- 空字符串，本是`false`，返回`true`

- 非空字符串，返回`false`
- 数值`0` ，返回`true`
- 非数值`0`，返回`false`
- `null`，返回`true`
- `NaN`，返回`true`
- `undefined`，返回`true`

使用两个叹号 `!!`，相当于调用了`Boolean()`函数，第一个叹号返回布尔值，第二个叹号取反

`console.log(!!"0")`

### 2.逻辑与(&&)

是一种短路操作符，如果第一个操作数就是`false`，则永远不会对后面的操作数求值，结果就是`false`。

也就是说，只要有一个操作数是`false`，则直接返回`false`，不会接着往下走。

### 3.逻辑或(||)

也是一种短路操作符，只要操作数一个为`true`，则不会往下执行，而直接返回`true`。

## 6.5 乘性操作符

### **1.乘法**

用符号 `*` 表示，可计算两个数值的乘积。在面对不是数值的操作时，会先被用`Number()`进行转换，比如`true`会被转换成 1，空字符串会被转换成 0等。

```js
console.log(15 * 10); //150
console.log(15 * NaN); //NaN
console.log("15" * "10"); //150
```

### **2.除法**

用符号 `/` 表示，可计算第一个数除以第二个数的商

```js
console.log(66 / 11); //6
console.log("10" / NaN); //NaN
```

### **3.取模**

用符号 `%` 表示，执行常规除法运算，返回余数

```js
console.log(11 % 2); //1
```

## 6.6 指数操作符

指数操作符用 `**` 表示，

```js
console.log(9 ** 3); //729，代表9的指数是3
console.log(Math.pow(9,3)); //729

let age = 10;
age **= 2; //100
```

## 6.7 加性操作符

一般的，`+`就是用来两数之和，但是如果其一是字符串时，加法的规则会变化：

- 如其一操作数为字符串，则会将另一操作数转换成字符串，再将两个字符串拼接

```js
let num = "10" + 5;
let num2 = 10 + "5";
console.log(num); //105，String
console.log(num2); //105，String
```

- 如两个操作数都为字符串，则直接将两字符串拼接

```js
let num = "10" + "55";
console.log(num); //1055，String
```

> 不要忽略加法操作中的数据类型



一般的，`-`就是两数之差，在面对不同的数据类型，减法的规则变化：

- 任一数为`NaN`，则返回`NaN`
- 任一数是字符串、布尔值、`null`或`undefined`，会先用`Number()`转换，再计算
- 任一数是对象，则会调用`valueOf()`取得数值。无`valueOf()`，则调用`toString()`方法，将得到字符串转换数值

## 6.8 关系操作符

比较两个值的操作，有`>`、`<`、`>=`、`<=`，返回布尔值。

在不同的数据类型比较时，也有一套规则：

- 如都是字符串，会比较对应字符的编码。需要注意，大小写的编码不同，需要将其转换成相同的大小写形式再比较
- 其一是数值，会将另一转换成数值，再比较
- 是对象，调用`valueOf()`，取的结果再如上规则比较

- 是布尔值，会将其转换数值再比较

> 涉及比较`NaN`时都返回`false`

## 6.9 相等操作符

### 1.等于和不等于

`==`代表等于，`!=`代表不等于。这两个操作符会进行**强制类型转换**，再比较两者是否相等。

两个符号的转换规则和比较规则：

- 布尔值的比较，`false == 0` 先将`false`转换成0，然后再比较两者是否相等

```js
console.log(false == 0); //true
```

- 其一是数值，另一是字符串，会尝试将字符串转换成数值，再比较相等。字符串`10`尝试转换成数值，再比较

```js
console.log("10" == 10); //true
```

- 两者都是对象，则会比较是否是同一对象

- 其一是`NaN`，`==`比较返回`false`，反之，`!=`比较返回`true`。两者都是`NaN`，也返回`false`
- `null`和`undefined`相等。且两者不能转换成其他类型值比较



:star: 71页，等于和不等于的更多示例及特殊情况比较

### 2.全等和全不等

`===`代表全等，`!==`代表全不等。这两个操作符在比较时**不会进行类型转换**。

```js
console.log("10" == 10); //true，等于，会进行类型转换，将字符串10转换成数值10
console.log("10" === 10); //false，全等，不会进行类型转换，数据类型不同返回false

console.log("10" !== 10); //true，全不等，不进行类型转换，返回true

console.log(null == undefined); //true
console.log(null === undefined); //false，不同的数据类型
```

> 保持严谨，推荐使用全等和全不等操作符

## 6.10 条件操作符

即三目运算法

```js
// 布尔表达式 ？ 第一个值 ： 第二个值
// 表达式为true，赋第一个值，表达式为false，赋第二个值
boolean_expression? true_value : false_value;
```

## 6.11 赋值操作符

使用`=`等于号来赋值，将右边的值赋给左边的变量。比如`let num = 15;`

复合赋值：

- `*=` 乘后赋值
- `/=` 除后赋值
- `+=` 加后赋值
- `-=` 减后赋值
- `%=` 取模后赋值
- ...

```js
let num = 15;
num = num + 15;
//使用复合赋值
let num = 15;
num +=15;
```



# 七、语句

流控制语句，语句通常使用一或多个关键字完成既定的任务。

## 7.1 if 语句

```js
if(表达式){
    //结果1
}else {
    //结果2
}
```



当表达式为`true`时，执行**结果1**的代码；表达式为`false`，执行**结果2**的代码。

## 7.2 do-while语句

`do-while`语句，在循环体内代码会先执行一次

```js
do{
    //先执行一边...
} while (表达式){}
```

## 7.3 while语句

先检测退出条件，再执行循环体内的代码

```js
let i = 0;
while( i < 10){
    i += 2;
}
console.log(i); //10
```

## 7.4 for语句

```js
for(let i = 0; i < 10; i++){
    console.log(i);
}// 0 - 9
```

求值结果`i < 10`为true，则继续执行循环体，如为`false`，则中止循环。

## 7.5 for-in语句

`for-in`语句可以枚举对象中的属性

```js
let arr = [1,2,3,4,5]
//循环枚举出每个数字
for(let i in arr){
    console.log(arr[i]);
} //1,2,3,4,5
```

## 7.6 for-of语句

`for-of`语句可用于遍历可迭代对象的元素

```js
let arr = [1,2,3,4,5]
for(let i of arr){
    console.log(i);
} //1,2,3,4,5
```

## 7.7 **break** 和 **continue** 语句

`break`语句会立即跳出循环，强制执行循环后的下一条语句。`continue`语句也立即退出循环，会再次从循环顶部开始执行。

## 7.8 with语句

不推荐

## 7.9 switch语句

```js
let i = 25;

switch(i){
    case 10:
        console.log("10");
        break;
    case 25:
        console.log("25");
        break;
    case 35:
        console.log("35");
        break;
    default:
        console.log("默认的");
}
```

在任何条件都不满足时，就会执行`default`执行的语句。`break`用来跳出语句。

`switch`可以用于所有数据类型，如上的`i`可以是变量或表达式，然后再匹配。

## 7.10 函数

函数可以封装语句，然后在各处执行。函数使用`function`声明。

```js
function (params){
    //执行语句
}
```

`js`的函数不需要指定返回值，可以使用`return`来返回值或者不带返回值，`return;`，这样函数会停止执行返回`undefined`。

> 在`return`后的语句将不会运行。



严格模式对函数限制：

- 不能以`eval`或`arguments`作名称
- 参数不能命名`eval`或`arguments`
- 参数不能同一名称

